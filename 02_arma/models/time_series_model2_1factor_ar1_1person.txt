#################################################################
  # AR(1) model for one latent factor with 3 indicators
  # of a single person
#################################################################

model {

  ###############################################################
    # Likelihood (model definition)
  ###############################################################

  # Loop through time points t = 1...Nt
  for (t in 1:Nt){
    # Loop through each indicator j = 1...3
     for(j in 1:3){
      # Let the outcome y of indicators 1 to 3 (BAI items)
      # at time t follow a normal distribution
      # with mean mu.y[i,j] and precision psi.y[j]
      y[t, j] ~ dnorm(mu.y[t, j], psi.y[j])
     }

    # Let the latent factors at time t follow a 
    # normal distribution with mean mu.eta[t] 
    # and precision psi.eta
    eta[t] ~ dnorm(mu.eta[t], psi.eta)
  }

  ####################### Time structure ########################
  
  # Set the mean of the outcome y at t=1 (intercept)
  # to the alpha parameter
  mu.eta[1] <- alpha
  
  # Loop through time points t = 2...Nt
  # and define the mean structure of the outcome y for t>1
  for (t in 2:Nt) {
    # Define the centered version of latent factor eta at time t-1
    # by subtracting the intercept
    eta.center[t - 1] <- eta[t - 1] - alpha
    # Let the mean of latent factor eta follow an AR(1) structure
    mu.eta[t] <- alpha + beta * eta.center[t - 1]
  }

  ###################### Factor structure #######################
  
  # Loop through time points t = 1...Nt
  # and define the mean structure for the Factor structure 
  # (invariant over time, no AR structure)
  for (t in 1:Nt) {
    # Let the factor eta load on indicators 10 to 12 (BAI scale)
    # using the first indicator for scaling
    mu.y[t, 1] <- eta[t]
    mu.y[t, 2] <- nu.y[1] + lambda.y[1] * eta[t]
    mu.y[t, 3] <- nu.y[2] + lambda.y[2] * eta[t]
  }
  

  ###############################################################
    # Priors
  ###############################################################

  # Loop through each indicator j = 1..3
  for (j in 1:3) {
    # Let the residual precision of indicator j 
    # follow a gamma distribution
    psi.y[j] ~ dgamma(1, 1)
  }
  
  # Let the precision of factor eta
  # follow a gamma distribution
  psi.eta ~ dgamma(1, 1)

  ####################### Time structure ########################

  # Let the intercept alpha follow a normal distribution
  alpha ~ dnorm(0, 0.1)
  # Let the autoregressive coefficient beta follow 
  # a uniform distribution
  beta  ~ dunif(-1, 1)
  
  ###################### Factor structure #######################

  # Loop through free factor loadings and intercepts l = 1..2
  for(l in 1:2) {
    # Let each factor loading follow a normal distribution
    # truncated from below at 0
    lambda.y[l] ~ dnorm(0.5, 1)I(0,)
    # Let each factor loading follow a normal distribution
    nu.y[l] ~ dnorm(0, 0.01)
  }

  
  ###############################################################
    # Transformations to obtain (co)variances
  ###############################################################
  
  # Loop through each indicator j = 1..3
  for (j in 1:3) {
    # Calculate the residual variance of indicator j
    sigma.y[j] <- 1 / psi.y[j]
  }
  
  # Calculate the variance of factor eta
  sigma.eta <- 1 / psi.eta


  ###############################################################
    # Standardize factor loadings
  ###############################################################

  # Calculate the standardized factor loadings 
  # lambda.y.strd[indicator_index]
  # by multiplying with the standard deviation of 
  # the according factor
  # -> the square root of the variance sigma.eta[factor_index]
  # and dividing by the standard deviation of 
  # the according indicator
  # -> the square root of the squared factor loading 
  #   lambda.y[loading_index]^2 multiplied with the
  #   variance sigma.eta[factor_index] plus the 
  #   residual variance sigma.y[indicator_index]


  # Calculate the standardized factor loadings for 
  # the first indicator  which was used for scaling
  lambda.y.strd[1] <- (1 * sqrt(sigma.eta) / 
              sqrt(sigma.eta + sigma.y[1]))
    
  # Calculate the standardized factor loadings for 
  # the second indicator
  lambda.y.strd[2] <- (lambda.y[1] * sqrt(sigma.eta) 
              / sqrt(lambda.y[1]^2 * sigma.eta + sigma.y[2]))

  # Calculate the standardized factor loadings for 
  # the third indicator
  lambda.y.strd[3] <- (lambda.y[2] * sqrt(sigma.eta) 
              / sqrt(lambda.y[2]^2 * sigma.eta + sigma.y[3]))

}
