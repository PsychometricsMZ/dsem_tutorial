#################################################################
  # AR(1) 2-level model for four latent factors
  # with person-specific random intercept
#################################################################

model{

  ###############################################################
    # Likelihood (model defintion)
  ###############################################################

  # Loop through the number of participants/patients 1...N
  for(i in 1:N){

    ########################## level 2 ##########################
    
    # Let the person-specific random intercept follow a normal 
    # distribution with mean vector mu.zeta21 and 
    # precision psi.zeta21 for all four factors
    zeta21[i, 1:4] ~ dmnorm(mu.zeta21[1:4], psi.zeta21[1:4, 1:4]) 
    
    ########################## level 1 ##########################

    # Loop through each time point t = 1...Nt
    for(t in 1:Nt){
      for(j in 1:12){
        # Let the outcome y of indicator j+9 (BAI items)
        # at time t follow a normal distribution
        # with mean mu.y[i,j] and precision psi.y[j]
        y[i, t, j] ~ dnorm(mu.y[i, t, j], psi.y[j])
      }

      # Let latent factors eta at time t for person i
      # follow a multivariate normal distribution with  
      # mean mu.eta[i, t, 1:4] and precision matix psi.eta
      eta[i, t, 1:4] ~ dmnorm(mu.eta[i, t, 1:4], psi.eta[1:4, 1:4])
    }

    ####################### Time structure #######################

    # Loop through each factor k = 1...4
    for(k in 1:4){
      # Add random intercept zeta21[i, k] to AR(1) parameter alpha
      # to define a new alpha parameter
      alpha.new[i, k] <- alpha[k] + zeta21[i, k]
      
      # Set the mean of the factor eta at t=1 (intercept)
      # to the new alpha parameter
      mu.eta[i, 1, k] <- alpha.new[i, k]
    }

    # Define the mean structure of the outcome for t>1
    # Loop through remaining time points t = 2...Nt
    for(t in 2:Nt){
      # Loop through each factor k = 1...4
      for(k in 1:4){
        # Define the centered version of factor eta at time t-1
        # by subtracting the intercept
        eta.center[i, t-1, k] <- eta[i, t-1, k] - alpha.new[i, k]
        # Let the mean of factor eta  follow an AR(1) structure
        # by adding each factor individually
        mu.eta[i, t, k] <- alpha.new[i, k] 
                        + beta[k, 1] * eta.center[i, t-1, 1] 
                        + beta[k, 2] * eta.center[i, t-1, 2]
                        + beta[k, 3] * eta.center[i, t-1, 3]
                        + beta[k, 4] * eta.center[i, t-1, 4]
      }
    }
  
    ##################### Factor structure ######################
      
      # Define the mean structure of the outcome y
      # through factor loadings lambda.y and intercepts nu.y
      # using the first indicator per factor for scaling
      # (no additional time-structures)

    # Loop through time points 1...Nt
    for(t in 1:Nt){
      # Let the first latent factor eta[i, t, 1] load on 
      # indicators 1 to 3  (WAI sub-scale TASK)
      mu.y[i, t, 1] <-                         eta[i, t, 1]
      mu.y[i, t, 2] <- nu.y[1] + lambda.y[1] * eta[i, t, 1]
      mu.y[i, t, 3] <- nu.y[2] + lambda.y[2] * eta[i, t, 1]
      
      # Let the second latent factor eta[i,2] load on
      #  indicators 4 to 6 (WAI sub-scale GOAL)
      mu.y[i, t, 4] <-                         eta[i, t, 2]
      mu.y[i, t, 5] <- nu.y[3] + lambda.y[3] * eta[i, t, 2]
      mu.y[i, t, 6] <- nu.y[4] + lambda.y[4] * eta[i, t, 2]
      
      # Let the third latent factor eta[i,3] load on 
      # indicators 7 to 9 (WAI sub-scale BOND)
      mu.y[i, t, 7] <-                         eta[i, t, 3]
      mu.y[i, t, 8] <- nu.y[5] + lambda.y[5] * eta[i, t, 3]
      mu.y[i, t, 9] <- nu.y[6] + lambda.y[6] * eta[i, t, 3]
      
      # Let the forth latent factor eta[i,4] load on 
      # indicators 10 to 12 (BAI scale)
      mu.y[i, t, 10] <-                         eta[i, t, 4]
      mu.y[i, t, 11] <- nu.y[7] + lambda.y[7] * eta[i, t, 4]
      mu.y[i, t, 12] <- nu.y[8] + lambda.y[8] * eta[i, t, 4]
    }
    
  }


  ###############################################################
    # Priors
  ###############################################################
  
  # Loop through each indicator j = 1....12
  for(j in 1:12){
    # Let the residual precision of indicator j 
    # follow a gamma distribution
    psi.y[j] ~ dgamma(1, 1)
  }
  
  # Let the precision matrix of the latent factors
  # follow a Wishart distribution with hyperprior psi0
  psi.eta[1:4 ,1:4] ~ dwish(psi0, 4)

  # Let the precision of random intercept follow a 
  # Wishart distribution for each of the four factors
  psi.zeta21[1:4, 1:4] ~ dwish(psi0, 4)

  ####################### Time structure ########################

  # Loop through each factor k = 1...4
  for(k in 1:4){
    # Let the intercept alpha follow a normal distribution
    alpha[k]~ dnorm(0, 10)
    for(j in 1:4){
      # Let the autoregressive coefficient beta follow 
      # a uniform distribution
      beta[k,j] ~ dunif(-1,1)
    }
  }

  ###################### Factor structure #######################

  # Loop through the number of free factor loadings 
  # and intercepts l = 1..8
  for(l in 1:8){
    # Let each factor loading follow a normal distribution
    lambda.y[l] ~ dnorm(0.5, 1)I(0,)
    # Let each intercept follow a normal distribution
    nu.y[l] ~ dnorm(0, 0.01)
  }


###############################################################
    # Transformations to obtain (co)variances
  ###############################################################

  # Loop through each indicator j = 1....12
  for(j in 1:12){
    # Calculate the residual variance of indicator j
    sigma.y[j] <- 1 / psi.y[j]
  }
  
  # Calculate covariance matrix of the latent factors
  sigma.eta[1:4, 1:4] <- inverse(psi.eta[1:4, 1:4])

  # Calculate the covariance matrix of the random effects
  sigma.zeta21[1:4, 1:4] <- inverse(psi.zeta21[1:4, 1:4])


  # Calculate the correlation matrix of the latent factors
  # and the according random intercepts
  # Loop through the number of factors k = 1...4
  for(k in 1:4){
    # Loop through the number of factors m = 1...4 again
    for(m in 1:4){
      # Calculate the correlation between factors k and m
      # by dividing their covariance sigma.eta[k,m] by the
      # square root of the product of their variances
      rho.eta[k,m] <- sigma.eta[k,m] / sqrt(sigma.eta[k,k] 
                            * sigma.eta[m,m])
      # Calculate the correlation between the random intercepts
      rho.zeta21[k,m] <- sigma.zeta21[k,m] / sqrt(sigma.zeta21[k,k] 
                            * sigma.zeta21[m,m])
    }
  }
  

  ###############################################################
    # Standardize factor loadings
  ###############################################################

  # Calculate the standardized factor loadings 
  # lambda.y.strd[indicator_index]
  # by multiplying with the standard deviation of 
  # the according factor
  # -> the square root of the variance sigma.eta[factor_index]
  # and dividing by the standard deviation of 
  # the according indicator
  # -> the square root of the squared unstrd factor loading 
  #   lambda.y[loading_index]^2 mulitiplied with the
  #   variance sigma.eta[factor_index] plus the 
  #   residual variance sigma.y[indicator_index]

  # Loop through the number of factors m = 1...4
  for(m in 1:4){
    # Define the index of the first indicator of factor m
    index_indicator_1[m] <- (m-1)*3+1
    # Calculate the standardized factor loadings for 
    # the first indicator  which was used for scaling
    lambda.y.strd[(m-1)*3+1] <- (1 * sqrt(sigma.eta[m,m]) 
                / sqrt(sigma.eta[m,m] + sigma.y[index_indicator_1[m]]))
    
    # Define the index of the second indicator of factor m
    index_indicator_2[m] <- (m-1)*3+2
    # Define the index of the according unstrd factor loading
    index_loading_2[m] <- (m-1)*2+1
    # Calculate the standardized factor loadings for 
    # the second indicator
    lambda.y.strd[(m-1)*3+2] <- (lambda.y[index_loading_2[m]] 
                * sqrt(sigma.eta[m,m]) 
                / sqrt(lambda.y[index_loading_2[m]]^2 * sigma.eta[m,m] 
                   + sigma.y[index_indicator_2[m]]))

    # Define the index of the third indicator of factor m
    index_indicator_3[m] <- (m-1)*3+3
    # Define the index of the according unstrd factor loading
    index_loading_3[m] <- (m-1)*2+2
    # Calculate the standardized factor loadings for 
    # the third indicator
    lambda.y.strd[(m-1)*3+3] <- (lambda.y[index_loading_3[m]] 
                * sqrt(sigma.eta[m,m]) 
                / sqrt(lambda.y[index_loading_3[m]]^2 * sigma.eta[m,m] 
                    + sigma.y[index_indicator_3[m]]))
  }

}
