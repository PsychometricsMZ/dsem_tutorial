#################################################################
  # Latent state switching AR(1) 2-level model
  # with person-specific random intercept and slope
  # with two states corresponding to single factors
#################################################################

model{

  # Set the probability of transitioning from state 2 to state 1
  # P(S_t = 1 | S_t-1 = 2)
  P2[1] ~ dunif(0, .1)
  # Note: this can also be changed, e.g., with priors such as
  # P2[1] <- 0.05

  # Set the probability of remaining in state 2
  # P(S_t = 2 | S_t-1 = 2)
  P2[2] <- 1 - P2[1]

  ###############################################################
    # Likelihood (model definition)
  ###############################################################

  # Loop through each individual i = 1...N
  for (i in 1:N) {

    ########################## level 2 ##########################
    
    # Let the person-specific random intercept and slope 
    # follow a multivariate normal distribution 
    # with mean 0 and precision psi.zeta21
    zeta21[i, 1:2] ~ dmnorm(mu.zeta2, psi.zeta21[1:2, 1:2])

    ########################## level 1 ##########################

    # Loop through each time point t = 1...Nt
    for (t in 1:Nt) {
      for (j in 1:3) {
        # Let the outcome y of indicator j (BAI items)
        # at time t follow a normal distribution
        # with mean mu.y[i, t, j, S[i, t]] and precision psi.y[j]
        y[i, t, j] ~ dnorm(mu.y[i, t, j, S[i, t]], psi.y[j])
      }

      # Let latent factors eta of states 1 and 2
      # at time t for person i follow normal distributions
      # with the same precisions psi.eta.S1 and psi.eta.S2
      eta.S1[i, t] ~ dnorm(mu.eta.S1[i, t], psi.eta.S1)
      eta.S2[i, t] ~ dnorm(mu.eta.S2[i, t], psi.eta.S2)
    }

   ###################### State transition #######################
    
    # Let all persons start in state 1 at time t = 1
    S[i, 1] <- 1
    
    # Loop through remaining time points t = 2...Nt
    for(t in 2:Nt){
      # Logistic model for the probability of remaining in state 1
      # P(S_t = 1|S_t-1 = 1) using the information from the factors
      # under state S = 1
      logit(P1[i, t, 1]) <- b2[1] + b2[2] * eta.S1[i, t-1]

      # Set the probability of transitioning from state 1 to state 2
      # P(S_t = 2 | S_t-1 = 1)
      P1[i, t, 2] <- 1 - P1[i, t, 1]
      
      # Define the transition matrix depending on the previous state:
      # If person i was in state 1 at time t-1 (S[i, t-1] == 1) 
      # -> use P1[i, t, 1:2]
      # If person i was in state 2 at time t-1 -> use P2[1:2]
      PS[i, t, 1:2] <- ifelse(S[i, t-1]==1, P1[i, t, 1:2], P2[1:2])
      
      # Sample the states from a categorical distribution
      S[i, t] ~ dcat(PS[i, t, 1:2]) 
    }

     ####################### Time structure #######################

    # Add random intercept zeta21 to AR(1) alpha parameter
    # for both states
    alpha.S1.new[i] <- alpha.S1 + zeta21[i,1]
    alpha.S2.new[i] <- alpha.S2 + zeta21[i,1]

    beta.S1.new[i] <- beta.S1 + zeta21[i,2]
    beta.S2.new[i] <- beta.S2 + zeta21[i,2]
    
    # Set the mean of the factor etas at t=1 (intercept)
    # to the new alpha parameter
    mu.eta.S1[i, 1] <- alpha.S1.new[i]
    mu.eta.S2[i, 1] <- alpha.S2.new[i]

    # Define the mean structure of the outcome for t>1
    # Loop through time points 2...Nt
    for(t in 2:Nt){      
      # Define the centered version of factors eta.S1 and eta.S2
      eta.center.S1[i, t-1] <- eta.S1[i, t-1] - alpha.S1.new[i]
      eta.center.S2[i, t-1] <- eta.S2[i, t-1] - alpha.S2.new[i]

      # Let the conditional mean of factor eta.S1 follow an AR(1) structure
      mu.eta.S1[i, t] <- alpha.S1.new[i] + beta.S1.new[i] * eta.center.S1[i, t-1]
      # Let the conditional mean of factor eta.S2 follow an AR(1) structure
      mu.eta.S2[i, t] <- alpha.S2.new[i] + beta.S2.new[i] * eta.center.S2[i, t-1]
    }
    
    ##################### Factor structure ######################

    # Loop through time points t = 1...Nt
    # and define the mean structure for the Factor structure 
    # (invariant over time, no AR structure)
    for(t in 1:Nt){
      # Let the factor eta.S1 load on indicators 1 to 3
      # using the first indicator for scaling
      mu.y[i, t, 1, 1] <-                          eta.S1[i, t]
      mu.y[i, t, 2, 1] <- nu.y[1] + lambda.y[1] * eta.S1[i, t]
      mu.y[i, t, 3, 1] <- nu.y[2] + lambda.y[2] * eta.S1[i, t]
      
      # Let the factor eta.S2 load on indicators 1 to 3
      # with the same factor loadings as for eta.S1
      mu.y[i, t, 1, 2] <-                          eta.S2[i, t]
      mu.y[i, t, 2, 2] <- nu.y[1] + lambda.y[1] * eta.S2[i, t]
      mu.y[i, t, 3, 2] <- nu.y[2] + lambda.y[2] * eta.S2[i, t]      
    }
  }

  ###############################################################
    # Priors
  ###############################################################

  # Loop through each indicator j = 1..3
  for(j in 1:3){
    # Let the residual precision of indicator j 
    # follow a gamma distribution
    psi.y[j] ~ dgamma(1, 1)
  }
  
  # Let the precision of factor eta.S1
  # follow a gamma distribution
  psi.eta.S1 ~ dgamma(1, 1)
  # and constrain across states
  psi.eta.S2 <- psi.eta.S1

  # Let the precision of random intercept and slope follow a 
  # wishart distribution with hyperparameter psi0 and df=2
  psi.zeta21[1:2,1:2] ~ dwish(psi0, 2)

  ####################### Time structure ########################

  # Let the intercept alpha.S1 follow a normal distribution
  alpha.S1 ~ dnorm(0, 0.001)
  # Define a normal distribution that determines the
  # difference between alpha.S1 and alpha.S2
  delta.alpha ~ dnorm(sqrt(sigma.eta.S1), 1)T(0, )
  # Let the intercept alpha.S2 follow a distribution composed of
  # the difference between the distribution of alpha.S1 and
  # delta.alpha
  alpha.S2 <- alpha.S1 - delta.alpha
  # Let the autoregressive coefficient beta follow a uniform
  # distribution
  beta.S1 ~ dunif(0, 1)
  beta.S2 ~ dunif(0, 1)

  ###################### Factor structure #######################

  # Loop through free factor loadings and intercepts l = 1..2
  for(l in 1:2){
    # Let each factor loading follow a normal distribution
    # truncated from below at 0
    lambda.y[l] ~ dnorm(0.5, 1)I(0, )
    # Let each factor loading follow a normal distribution
    nu.y[l] ~ dnorm(0, 0.01)
  }

  ###################### State transition #######################

  # Let the transition intercept follow a normal distribution
  b2[1] ~ dnorm(0, 0.01)
  # Let the transition slope follow a normal distribution
  # truncated from below at 0
  b2[2] ~ dnorm(0, 1)I(0, )
  b2[3] ~ dnorm(0, 1)I(0, )
  b2[4] ~ dnorm(0, 1)


  ###############################################################
    # Transformations to obtain (co)variances
  ###############################################################
  
  # Loop through each indicator j = 1..3
  for(j in 1:3){
    # Calculate the residual variance of indicator j
    sigma.y[j] <- 1 / psi.y[j]
  }
  
  # Calculate the variance of factors eta.S1 and eta.S2
  sigma.eta.S1 <- 1 / psi.eta.S1
  sigma.eta.S2 <- 1 / psi.eta.S2

  # Calculate the variance of the random slope
  sigma.zeta21[1:2,1:2] <- inverse(psi.zeta21[1:2,1:2])

  # Loop through the number of participants/patients 1...N
  for(i in 1:N){
    # Calculate the average S[i,t] as a proxy for switching
    St[i] <- Nt + 1 - mean(S[i, 1:(Nt)] - 1) * Nt
    # Save the final state membership
    Send[i] <- S[i, Nt]
  }

}
